<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Arcade Shooter — Works on Phone / Pad / Laptop</title>
  <style>
    :root{--bg:#0b1220;--accent:#4ee1a0;--danger:#ff6b6b;--muted:#94a3b8}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#08101a 0%, #07121a 60%);color:#e6eef7;font-family:Inter, system-ui, Arial}
    #gameWrap{display:flex;height:100vh;gap:12px;align-items:stretch}
    canvas{flex:1;display:block;background:transparent}
    #ui{width:320px;max-width:38%;min-width:240px;padding:14px;box-sizing:border-box;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));backdrop-filter:blur(6px)}
    h1{font-size:18px;margin:0 0 10px}
    .panel{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;margin-bottom:12px}
    .row{display:flex;justify-content:space-between;align-items:center}
    button{background:var(--accent);border:0;padding:8px 10px;border-radius:8px;color:#042024;font-weight:700;cursor:pointer}
    .small{font-size:13px;color:var(--muted)}
    .controls{font-size:13px;line-height:1.6}
    #touchHints{display:none}
    @media (max-width:900px){#ui{position:absolute;right:12px;top:12px;opacity:0.95;max-width:46%}#touchHints{display:block}}
    /* on-screen fire button */
    .touch-fire{position:fixed;right:18px;bottom:18px;width:86px;height:86px;border-radius:50%;background:radial-gradient(circle at 30% 30%, rgba(255,255,255,0.06), rgba(255,255,255,0.02));display:flex;align-items:center;justify-content:center;font-weight:800;color:var(--danger);font-size:18px;box-shadow:0 6px 18px rgba(0,0,0,0.5);}
    .touch-stick{position:fixed;left:18px;bottom:18px;width:140px;height:140px;border-radius:50%;background:radial-gradient(circle at 20% 20%, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center}
    .stick-knob{width:56px;height:56px;border-radius:50%;background:rgba(255,255,255,0.06);}
    footer{position:fixed;left:12px;bottom:12px;color:var(--muted);font-size:12px}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="c"></canvas>
    <div id="ui">
      <h1>Arcade Shooter</h1>
      <div class="panel">
        <div class="row"><div>Score</div><div id="score">0</div></div>
        <div class="row"><div>Health</div><div id="hp">100</div></div>
        <div class="row"><div>Level</div><div id="level">1</div></div>
      </div>

      <div class="panel">
        <div class="small">How to play</div>
        <div class="controls">
          Desktop: WASD or Arrow keys to move, Mouse to aim, Click / Space to shoot.<br>
          Mobile / Tablet: Drag left joystick to move, Hold/right side to aim and auto-fire. Tap the red button to fire.
        </div>
      </div>

      <div class="panel">
        <div class="row"><div>Pause</div><button id="btnPause">Pause</button></div>
        <div style="height:8px"></div>
        <div class="row"><div>Restart</div><button id="btnRestart">Restart</button></div>
      </div>

      <div class="panel small">
        Built with a single HTML file — copy to <code>index.html</code> and open in any browser.
      </div>

    </div>
  </div>

  <div id="touchHints">
    <div class="touch-stick" id="stick"><div class="stick-knob" id="knob"></div></div>
    <div class="touch-fire" id="fireBtn">FIRE</div>
  </div>
  <footer>Made for phone / pad / laptop — responsive canvas</footer>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(window.innerWidth * DPR - (window.innerWidth>900?320*DPR:0));
    canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = (window.innerWidth>900?window.innerWidth-320:window.innerWidth) + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Game state
  let running = true;
  let score = 0;
  let level = 1;
  let spawnTimer = 0;
  let enemies = [];
  let bullets = [];
  let particles = [];

  const player = {x:400,y:300,r:14,spd:180,angle:0,hp:100,fireCooldown:0};

  // controls
  const keys = {};
  window.addEventListener('keydown', e=>{keys[e.key.toLowerCase()]=true; if(e.code==='Space') e.preventDefault();});
  window.addEventListener('keyup', e=>{keys[e.key.toLowerCase()]=false});

  // mouse
  let mouse = {x:player.x,y:player.y,down:false};
  canvas.addEventListener('mousemove', e=>{const rect=canvas.getBoundingClientRect(); mouse.x=(e.clientX-rect.left); mouse.y=(e.clientY-rect.top)});
  canvas.addEventListener('mousedown', e=>mouse.down=true);
  window.addEventListener('mouseup', e=>mouse.down=false);

  // touch: left stick + right aim
  const stick = document.getElementById('stick');
  const knob = document.getElementById('knob');
  const fireBtn = document.getElementById('fireBtn');
  let stickBase = {x:70,y:window.innerHeight-70};
  let knobPos = {x:stickBase.x,y:stickBase.y};
  let activeStickId = null;
  let activeAimId = null;
  let aimingTouchPos = null;
  let autoFire = false;

  function updateStickBase(){stickBase={x:70,y:window.innerHeight-70}; stick.style.left=(stickBase.x-70)+'px'; stick.style.bottom='18px';}
  updateStickBase();
  window.addEventListener('resize', updateStickBase);

  window.addEventListener('touchstart',(e)=>{
    for(const t of e.changedTouches){
      const x = t.clientX, y=t.clientY;
      // left half -> stick
      if(x < window.innerWidth/2 && activeStickId===null){
        activeStickId = t.identifier;
        knobPos = {x: x, y: y};
        knob.style.transform = 'translate('+(-28)+'px,'+(-28)+'px)';
      } else if(activeAimId===null){
        activeAimId = t.identifier;
        aimingTouchPos = {x,y};
        autoFire = true;
      }
    }
  },{passive:true});
  window.addEventListener('touchmove',(e)=>{
    for(const t of e.changedTouches){
      if(t.identifier===activeStickId){
        // move player with drag
        const dx = t.clientX - stickBase.x;
        const dy = t.clientY - stickBase.y;
        const max = 50;
        const mx = Math.max(-max,Math.min(max,dx));
        const my = Math.max(-max,Math.min(max,dy));
        knob.style.transform = `translate(${mx-28}px,${my-28}px)`;
        // normalized vector
        player._moveX = mx/ max;
        player._moveY = my/ max;
      } else if(t.identifier===activeAimId){
        aimingTouchPos = {x:t.clientX,y:t.clientY};
      }
    }
  },{passive:true});
  window.addEventListener('touchend',(e)=>{
    for(const t of e.changedTouches){
      if(t.identifier===activeStickId){activeStickId=null; player._moveX=0; player._moveY=0; knob.style.transform='translate(-28px,-28px)';}
      if(t.identifier===activeAimId){activeAimId=null; aimingTouchPos=null; autoFire=false;}
    }
  });
  fireBtn.addEventListener('touchstart', e=>{autoFire=true}, {passive:true});
  fireBtn.addEventListener('touchend', e=>{autoFire=false}, {passive:true});

  // helpers
  function rnd(min,max){return Math.random()*(max-min)+min}
  function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy)}

  function spawnEnemy(){
    const edge = Math.floor(rnd(0,4));
    let x,y;
    if(edge===0){x = -20; y = rnd(0,canvas.height)}
    if(edge===1){x = canvas.width+20; y = rnd(0,canvas.height)}
    if(edge===2){x = rnd(0,canvas.width); y = -20}
    if(edge===3){x = rnd(0,canvas.width); y = canvas.height+20}
    const s = rnd(10,26) + level*2;
    enemies.push({x,y,r:s,spd: rnd(30,80)+level*10, hp: Math.floor(s/6)+level, color: '#ffb86b'})
  }

  function createBullet(x,y,angle,owner='player'){ bullets.push({x,y,dx:Math.cos(angle)*420,dy:Math.sin(angle)*420,r:4,owner}) }

  function explode(x,y,color,n=12){for(let i=0;i<n;i++){particles.push({x,y,dx:Math.cos(i/n*Math.PI*2)*rnd(20,260),dy:Math.sin(i/n*Math.PI*2)*rnd(20,260),ttl: rnd(0.3,0.9),age:0,color})}}

  // main update
  let last = performance.now();
  function step(now){
    const dt = Math.min(0.05,(now-last)/1000);
    last = now;
    if(running){
      update(dt);
      render();
    } else {
      // dim overlay when paused
      render();
      ctx.fillStyle = 'rgba(2,4,8,0.45)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'white'; ctx.font='24px system-ui'; ctx.textAlign='center'; ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function update(dt){
    // movement
    let mvx=0,mvy=0;
    if(typeof player._moveX==='number'){ mvx = player._moveX; mvy = player._moveY }
    // keyboard
    if(keys['w']||keys['arrowup']) mvy -= 1;
    if(keys['s']||keys['arrowdown']) mvy += 1;
    if(keys['a']||keys['arrowleft']) mvx -= 1;
    if(keys['d']||keys['arrowright']) mvx += 1;
    const mag = Math.hypot(mvx,mvy) || 1;
    player.x += (mvx/mag)*player.spd*dt;
    player.y += (mvy/mag)*player.spd*dt;
    // clamp
    player.x = Math.max(10, Math.min(canvas.width-10, player.x));
    player.y = Math.max(10, Math.min(canvas.height-10, player.y));

    // aim
    if(aimingTouchPos){
      const rect=canvas.getBoundingClientRect();
      player.angle = Math.atan2(aimingTouchPos.y-rect.top - player.y, aimingTouchPos.x-rect.left - player.x);
    } else {
      player.angle = Math.atan2((mouse.y) - player.y, (mouse.x) - player.x);
    }

    // firing
    player.fireCooldown -= dt;
    const wantFire = (mouse.down || keys[' '] || keys['space'] || autoFire);
    if(wantFire && player.fireCooldown<=0){
      player.fireCooldown = 0.12; // rate of fire
      const bx = player.x + Math.cos(player.angle)*(player.r+6);
      const by = player.y + Math.sin(player.angle)*(player.r+6);
      createBullet(bx,by,player.angle,'player');
    }

    // enemies spawn faster as level increases
    spawnTimer -= dt;
    if(spawnTimer <= 0){
      spawnTimer = Math.max(0.2, 1.2 - level*0.08);
      spawnEnemy();
    }

    // update bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.dx*dt; b.y += b.dy*dt;
      b.ttl = (b.ttl||3) - dt;
      if(b.x< -20 || b.x>canvas.width+20 || b.y<-20 || b.y>canvas.height+20 || b.ttl<=0){ bullets.splice(i,1); continue; }

      if(b.owner==='player'){
        for(let j=enemies.length-1;j>=0;j--){
          const e = enemies[j];
          const d = Math.hypot(b.x-e.x,b.y-e.y);
          if(d < e.r + b.r){
            e.hp -= 1; bullets.splice(i,1); explode(b.x,b.y,'#ffd0a8',6);
            if(e.hp<=0){ score += Math.round(10 + e.r*0.4 + level*2); explode(e.x,e.y,e.color,18); enemies.splice(j,1); }
            break;
          }
        }
      }
    }

    // update enemies movement
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      const angleToPlayer = Math.atan2(player.y - e.y, player.x - e.x);
      e.x += Math.cos(angleToPlayer)*e.spd*dt;
      e.y += Math.sin(angleToPlayer)*e.spd*dt;
      // collide with player
      const d = Math.hypot(e.x-player.x, e.y-player.y);
      if(d < e.r + player.r){
        // damage
        player.hp -= Math.max(1, Math.floor(e.r/8));
        explode((e.x+player.x)/2,(e.y+player.y)/2,'#ff9b9b',8);
        enemies.splice(i,1);
        if(player.hp<=0){
          running = false;
        }
      }
    }

    // particle update
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i]; p.age += dt; if(p.age > p.ttl){ particles.splice(i,1); continue; }
      p.x += p.dx*dt; p.y += p.dy*dt; p.dx *= 0.98; p.dy *= 0.98; p.color = p.color;
    }

    // level up based on score
    const nextLevelAt = 40 + level*60;
    if(score >= nextLevelAt){ level++; score = score - nextLevelAt; }

    // update UI
    document.getElementById('score').innerText = Math.max(0, score);
    document.getElementById('hp').innerText = Math.max(0, Math.floor(player.hp));
    document.getElementById('level').innerText = Math.max(1, level);
  }

  function render(){
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background stars
    for(let i=0;i<80;i++){ const x = (i*97)%canvas.width; const y = ((i*53)%canvas.height); ctx.fillStyle = 'rgba(255,255,255,' + (0.03 + (i%7)/140) + ')'; ctx.fillRect(x, y, 1,1); }

    // draw bullets
    for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill(); }

    // draw enemies
    for(const e of enemies){ ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fillStyle = e.color; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.18)'; ctx.stroke(); }

    // draw player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    // body
    ctx.beginPath(); ctx.arc(0,0,player.r,0,Math.PI*2); ctx.fillStyle = 'linear-gradient'; ctx.fillStyle = '#6bffd0'; ctx.fill();
    // gun
    ctx.fillStyle = '#052b26'; ctx.fillRect(player.r-2, -6, 16, 12);
    ctx.restore();

    // draw particles
    for(const p of particles){ const life = 1 - (p.age/p.ttl); ctx.globalAlpha = life; ctx.fillStyle = p.color; ctx.fillRect(p.x-2, p.y-2, 3,3); ctx.globalAlpha=1; }

    // HUD crosshair
    ctx.beginPath(); ctx.arc(player.x + Math.cos(player.angle)*28, player.y + Math.sin(player.angle)*28, 6,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.stroke();

    // game over
    if(!running){ ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='34px system-ui'; ctx.fillText('YOU DIED', canvas.width/2, canvas.height/2 - 10); ctx.font='18px system-ui'; ctx.fillText('Press Restart to play again', canvas.width/2, canvas.height/2 + 20); }
  }

  // buttons
  document.getElementById('btnPause').addEventListener('click', ()=>{ running = !running; document.getElementById('btnPause').innerText = running? 'Pause':'Resume'; });
  document.getElementById('btnRestart').addEventListener('click', ()=>{ restart(); });

  function restart(){ enemies=[]; bullets=[]; particles=[]; player.hp=100; player.x = Math.max(80, canvas.width/2); player.y = canvas.height/2; score = 0; level = 1; spawnTimer = 0.6; running = true; }

  // initial spawn
  spawnTimer = 0.6;
  restart();

  // cheat-ish: auto-fire while mouse down with setInterval fallback for mobile
  setInterval(()=>{ if(mouse.down) autoFire = true; else if(!activeAimId) autoFire = false; }, 100);

})();
</script>
</body>
</html>
